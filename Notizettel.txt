// =========================================================

Seminar "Clean Code"

Peter Loos

peter.loos@gmx.de
-----------------

https://github.com/pelocpp

30+ Jahren

C/C++,  Java, C#,  Mobile Progr. (Java) // Android, JavaScript (Python)

   Rust

Guten Morgen

10.30 //  12.30 // ca. 15 Uhr  // 17 Uhr.

// =========================================================

2 Tools:

a) Unterlagen

Github

https://github.com/pelocpp

https://github.com/pelocpp/Seminar_Cpp_Clean_Code_November_2025

oder auch das Original:

https://github.com/pelocpp/cpp_clean_performant_secure


https://github.com/pelocpp/cpp_design_patterns



b) Visual Studio Community 2022

=======================================================

ToDo Liste:

Smart Pointer // std::shared_ptr // std::unique_ptr
       ==> std::weak_ptr
     
Besucher // Visitor

RAII

State

Command 

Observer

=======================================================

Clean Code C++

"Sauberer Code"

2 Flughöhen:

Von Oben:   Entwurf, Idiome, Design Pattern, 

Im Inneren: Elemente der Sprache, die Clean Code ermöglichen (Modern C++)

// Classic C++  // Modern C++ (C++ 11)


== Was sind meine Erwartungen

== Wo stehe ich in C++

== Was MUSS drin sein

== Ein Überblick tut es auch 

== Welche Sprachen spreche ich :)

// Misra, sauberer Code, 

// Kein Heap, Design Pattern, STL 

std::vector

STL:  Algorithmen   std::copy, std::transform, std::generate  // Lambda

=========================================================

Schnittstelle:

  Kontrakt, Vertrag

  Dieser ist an anderer Stelle zu implementieren.

Abstrakte Klasse:  Unvollständige Klasse

============================================================

Single Responsibility Prinzip (SRP)

Open-Closed Prinzip:

============================================================

== Habe Methoden / Klassen für einen bestimmten Anwendungsfall.

== Es kommen neue Anforderungen hinzu.


Wie löst man das ???

== Man versuche, vorhandene konkrete Realisierungen (methoden) durch eine Schnittstelle zu abstrahieren.

== Dadurch wird es "allgemeiner"

== Aufbauende Module können auf den Schnittstellen aufsetzen

== Es findet eine Entkopplung statt !!!
                  ===========

============================================================

Kann man "vordenken"  // Antizipatorischens Verhalten

Gratwanderung:   Könnte sich an dieser Stelle etwas ändern  

============================================================

Dependency Inversion Prinzip
----------------------------

„High-Level”-Module  ==> „Low-Level”-Module

Wenn Low-Level die Schnittstelle ändert: Problem ===> „High-Level”

==================================================

struct Point
{
   int m_x;
   int m_y;
}


FamilyTree ==> Relationships   // Enge Kopplung   ==>   Lose Kopplung

Besser:

FamilyTree ==> IRelationshipBrowser

Relationships  ==> IRelationshipBrowser

==================================================

Design Pattern:
---------------

Vorab:

== Text

== Bild

== Konzeptionelle Beispiel

== Real-World Beispiel

======================================================

Adapter
-------

Ermöglicht die Interaktion von Objekten mit inkompatiblen Schnittstellen.

== Ansprechen von inkompatiblen Methoden
== Benötige Zwischenschicht (KEINE Bibliothek): Hüllenobjekt (Wrapper)

   Ein Adapter ist ein Wrapper (Hüllenobjekt) um ein inkompatibles Objekt

Beispiel:

==: JSON
==> Daten:  XML
==> Daten:  JAML

Wiedervewenbare Lösung

==========================================

Strategy Pattern:
-----------------

== Ermöglicht den Austausch von Methoden

== Umbiegen von Aufrufen an bestimmte Realisierungen 

Beispiel:

UI Bibliothek:

== Kann zeichnen via GDI
== Kann zeichnen via Qt

a) draw (GDIContext) ........ Hmmm, diese Methode hängt von der Ausgabe DIREKT ab.

b) draw (Rectangle r)  .... Hmmm, wohin ???

   draw ==> Interface:

       interface IDraw:
          draw ();
         
        2 Mal realisieren:

        GDILibrary : public IDraw

        QtLibrary :  public IDraw

    Dies ist eine Umsetzung des Strategy - Pattern.

std::function:  

Ist ein Hüllenobjekt. Die Template Parameter beschreiben die SIGNATUR der gekapselten Methode.

Worum: Um quasi ALLES, was in C++ aufgerufen werden kann.

======================================================

Adapter
Strategy
Template Method

Template Method Pattern:   Einfach und Cool.


Beispiel:

Tetris 

Was haben alle 7 Figuren von Tetris während des Spielablaufs gemeinsam?

== Haben eine bestimmte Geometrie

== Sie bewegen sich auf eine bestimmte Weise identisch:

  -- nach links
  -- nach rechts
  -- nach unten
  -- drehen
  -- irgendwann ist die Bewegung zu Ende.

    Was ist das im Prinzip: Eine schablonenhafte Methode für ALLE Figuren.

    Template Method Pattern.

========================================================

Wann Adapter

Wann Strategy

Wann Template Method


Alle haben mit Methoden zu tun:

Adapter ===> Zielmethode ist DIREKT nicht aufrufbar

Template Methode ==> Kann einen allgemeinen Ablauf in EINER Methode vorgeben / festlegen.

Strategy ==> Austauschbarkeit von Funktionalität // Verhalten kann geändert werden.

// =========================================================

Allgemein:

a) Ein Pattern ist eine Hilfestellung.

b) Wie sehr muss ich mich an die Vorgaben halten???

c) Kollegen sollten das Pattern "wieder erkennen"

d) Abweichungen sind grundsätzlich möglich // man sollte sie begründen können.

  Am Ende: Es sollte die grundlegende Idee nicht geändert werden.

// =========================================================

Proxy:

Single Responsibility Idiom


Hülle: Ein Proxy kann als Hülle aufgefasst werden.

Diese kann zusätzliche Funktionalitäten erbringen,
die das Zielobjekt (SRP) unberührt lassen.

Lazy Loading
Eager Loading

Lazy: Faul // On Demand
Eager: Gierig

Smartphone // Embedded Device

Bilder Gallerie  // 10.000   // On Demand

== Durch wischen  // swipen   // Klein-Darstellung  // Thumb Nails // Ersatzdarstellung

Ein Bild: Benötigt viele Resources.

NICHT vorstellbar ist: Jedes Bild wird geladen.

==============================================================

Virtueller Konstruktor

// Prototype Pattern

Cooles Pattern

Erstelle eine Kopie eines Objekts durch einen Zeiger auf seinen Basistyp     Uhhhhhhhhhhh


a) Erstelle eine Kopie eines Objekts:    Kopier-Konstruktor

   Das ist nicht das Problem / die Frage ??????????

b) Beispiel / Motivation:

   Spieleprgrammierung.

   ChessFigure* board [8][8];

   Bauer:   Pawn
   Turm:    Rook
   König:   King
   Dame:    Queen
   Läufer:  Bishop

   class Pawn : public ChessFigure
   class Rook : public ChessFigure

   Nächste Schritt: Versuche // Zukunft :

       Kopie vom aktuellen Schachbrett: 


     ChessFigure*  copy[8][8] = board;   // 64 ChessFigure* Adressen / Pointer

     Will man hier Adressen kopieren ?????????????? Nein.

     Man will auch von den Figuren eine Kopie haben.  ====>  board[0][0]

     Ich will das Objekt, auf das der ZEIGER  board[0][0] zeigt, KOPIEREN.

     
     Das Kind ConcretePrototype leitet von Prototype ab.
     Deswegen geht das.

     ==============================================================

     Clean Code:

     Vererbung:   

     Wann setzt man Vererbung ein ???????????????????????

     Wenn man sich Methoden teilen möchten
     Wiederverwendung von Code
     Wenn es einen Hierarchie gibt ...

     Hilfestellung für diese Beobachtungen:
     -------------

     Klasse Rectangle
     Klasse ColoredRectangle

     Satz: Ein ColoredRectangle ist ein Rectangle

        Es gibt im Entwurf von SW Beziehungen // Relationsships:

        is-a Relationship // ist-ein Beziehung ===========>  Vererbung

    Klasse Point
    Klasse Line

    Satz: 

        Eine Linie hat viele Punkte

        Eine Linie ist ein Punkt : No
        Ein Punkt ist eine Linie:  No

        Eine Linie hat einen Anfangs- und Endepunkt.

        has-a Relationship // hat-ein Beziehung ===========>  Instanzvariablen

        Es sollte nur das eine Instanzvariable sein, was unbedingt benötigt wird.

        class Line
        {
             Point m_begin;
             Point m_end;
             int   i;           // NOOOOOOOOOOOOOOOO
             int   m_length;    // computed // computable property  // NOOOOOOOOOOOOOOOOO
                                // hmmmm, Berechnung dauert EXTREM lange ...
        }



  // class Line : public Point 
  // {
  // }

  Es gibt bei der is-a Beziehung SEHR SELTEN Abweichungen zum Entwurf.  // Barbara Liskov

  ======================================================================

  Frage:

  Methode ist in der Entwicklung ...

  Komplizierteres ... Hmm, das wird nichts .....

  ==> Neu schreiben // nochmals damit von vorne anfangen ...

  ==> kann man das eine oder anderen in ein Unterprogramm(-methode) auslagern
  
  ==> Bausteine ....

  ======================================================================

 Interfaces: >> Abstraktion

 YAGNI

 Zum Testen: 

 DRY:   ==> Haben wir das eine oder andere nicht in der STL ???

 Copy&Paste.

 ==> Abgabe // extr. Zeitdruck:

     Klasse 1 Fehler: Wurde nach 3 Tagen gefixed...

Usache: Ein Fehler wurde mit Copy & Paste wiederholt ...

POLS

===================================================================

const:

Wichtig oder nicht ??????????????????????????????????????

Auf eine Methode angewendet:

01: class Person
02: {
03: private:
04:     std::string   m_name;
05:     size_t        m_age;
06: 
07: public:
08:     Person() = default;
09:     Person(const std::string& name, size_t age)
10:         : m_name{ name }, m_age{ age }
11:     {}
12: 
13:     std::string getName() const { return m_name; }  // hier const auf die Methode angewendet ..
14:     size_t getAge() const { return m_age; }
15: };


const bedeutet hier (Lesbarkeit): Das Person-Objekt bleibt unverändert !

Noch was anderes ???

ii) Wenn ich aus Versehen ändern sollte, dann warnt mich der Compiler !!! Error.

iii) OO Programmierung

     Funktionale Programmierung  ==> Werbung: Performanz.

     CPU:  Reordering der CPU Befehle // CPU Pipelining // Performanz  // Parallelisierung ganz tief unten.

     Warum geht das: Kein STATE

     C++: Hmm, Problem der Instanzvariablen.

     Code-Generator // -Optimizer: Welche Methoden kann ein Optimizer am besten optimieren: 
     Solche, die den State nicht verändern: 'const'

     Fazit:  'const' ==> Optimizer  // Yes  // Hint

==============================================================

01: class Person
02: {
03: private:
04:     std::string   m_name;
05:     size_t        m_age;
06: 
07: public:
08:     Person() = default;
09:     Person(const std::string& name, size_t age)
10:         : m_name{ name }, m_age{ age }
11:     {}
12: 
13:     std::string getName() const { return m_name; }
14:     size_t getAge() const { return m_age; }
15: };

Gute Klasse / schlechte Klasse ???

Zeile 13: Hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm

const std::string& getName() const { return m_name; }

Eine kleine Frage verbunden: Wie lange ist diese Referenz gültig ???

So lange das Objekt Person lebt.

==========================================================================

STL

Why:  Better // Clean Clode relies upon STL

Robustheit

Walk-Through ...


STL:

== Container
== Iteratoren
== Algorithmen
== Aufrufbare Objekte (Funktor)

=> Transparenz

==========================

Jeder STL Container verwaltet seine Daten nach bestimmten Regeln.

NICHT alle Regeln sind publiziert // beschrieben.

std::vector:  Die Daten liegen DICHT aneinander. // ALLE 

std::list:    Hier liegen die Daten im Stile einer Linked List im Speicher.

Hash-Tabelle:  Python: Dictionary

               std::unordered_map

std::map:      Balancierter Baum  // Red-Black Tree


std::vector

6, 9, 13, 19, 28, 42, 63

neuer Wert = alter Wert * 1.5;

===================================================

STL Container

Operator[]:  Dieser geht nur bei "sequentiellen" Container:

   Daten liegen DICHT im Speicher.

==> Go for "Iteratoren"

Was ist ein STL Iterator ???

Man kann auch "Position" sagen.

Ein Iterator beschreibt eine Position in einem Container.

Vorsicht: Eine Position ist NICHT gleich dem WERT an dieser Position.

Offensichtlich hat jeder STL Container einen eigenen Typ für derartige Positionen.


Welches kOnzept haben Iteratoren:

3 Methoden:

Next
ValueOf
Equals

C++:  Konzept des Überladens von Operatoren:

operator ++
operator *
operator ==

=====================================================

Um Benachrichtigungen zu erhalten, wenn Ereignisse eintreten.”

Objekt:   State / Zustand / Änderungen.

Beispiel: Wetterdaten  ==> Interesse

Die sich für Änderungen interessieren  ...

Nomenklatur:

a) Objekt: State

   Subject, Event Source, Observable

b) Interessierten:

   Event Client, Event Sink (Senke), Observer

==> Ad Hoc:  Callback ...

==> Verfeinerungen

i) Klassisch (GoF)  // Interfaces

ii) Reine C++:     std::function 

===============================

Änderung:

update ==> Müssen ALLE Daten transportiert werden.

update:   Info senden, was hat sich geändert

Observer: Kann entscheiden, was er vmo Suibject holt ....

==============================================================

Command:

Ich will an einem Objekt eine Methode aufrufen ... zu einem SPÄTEREN Zeitpunkt.

Nicht synchron // asnchron

Beispiel:

a) ISR // Routine in einem hoch-prioren Kontext.

   Wenn ein Ereignis im OS eintrifft ... da hat man keine Zeit für langwierige Methodenausführungen.

   Es werden nur ALLE Infos für den Methodenaufruf abgespeichert (welches Zielobjekt, welche Methode, welche Parameter )

b) BankKonto:

   Die Aktualisierung eines Zielkontos erfolgt nachgelagert.

c) Es werden nur ALLE Infos für den Methodenaufruf abgespeichert (welches Zielobjekt, welche Methode, welche Parameter )

  Umsetzung:  Undo / Redo - Buffers.

Kritik:

== Das "konzeptionelle Beispiel" bewegt sich im GLEICHEN Thread.

== Wenn Kommandos zeitverzögert aufgerufen werden sollen,
   dann bin ich häufig in einem anderen Thread.

==> Andere Idee:

  Nachrichtenwartenschlange:  da kann man auch Methodenaufrufe ablegen ..

  Praxis-nähere Umsetzung:

  https://github.com/pelocpp/cpp_concurrency/blob/master/Programs/33_EventLoop/Readme.md

  =======================================================================

  STL Container
  STL Iteratoren
  STL Algorithmen

  
  =======================================================================

     int m = a;  // void printer(int a)
00007FF79A772C00  mov         eax,dword ptr [a]     <===
00007FF79A772C06  mov         dword ptr [m],eax  


    int m = a;  // void printer(int& a)
00007FF68A192C01  mov         rax,qword ptr [a]     <===
00007FF68A192C08  mov         eax,dword ptr [rax]   <===
00007FF68A192C0A  mov         dword ptr [m],eax  


for (int i = 0 ; i != 100000; ....) {
   printer(i);   // Release: Ersten 4 Parameter: Registern.
}

void printer(std::string a)  // 40 bytes:  Kopiere oder als Referenz übergebe

void printer(std::string& a)


Hint / Empfehlung:

Elem. Datentypen: Call-by_copy

Objekte: Call-by-Referenz // Pointer // NOT: Call-by-Copy


// ============================================

Clean / Modern: Lambda   // C++ 11

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

Einschub:

Aufrufbares Objekt // Funktor:

std::function ... 

Funktor: (Mathematik)  // Aufrufbares Objekt:

==> operator ()

C++ Definition: Objekte einer Klasse, die den Operator operator() überlädt,
bezeichnet man als aufrufbar.



Was ist ein Lambda:

A) Anschaulich:    Eine anonyme Funktion "inplace"

                   Sie kann Variablen aus dem umgebenden Scope verwenden:

                   Entweder als KOPIE oder via REFERENZ.

B) Aus Sicht von C++: 

   Ein Objekt einer anonymen Klasse, die den Operator operator() implementiert.

                      Sie kann Variablen aus dem umgebenden Scope verwenden:

                      Diese werden in dem Objekt der anonymen Klasse abgelegt:
                      Als Kopie oder mit einer Referenz auf das Original.

C) Bemerkung: Umgangssprachlich: "Ein Lambda ist eine Funktion"

              FALSCH: Ein Lambda ist ein OBJEKT  ... hmmm : Von welcher Klasse / Typ ???

Tool:   Cpp Insights

Präcompiler: Modern C++ ==> Classic C++

// -----------------

Lambdas sind Objekte:

Methoden und Membervariablen


mutable:  C++ aus den ersten Tagen.

==================================================

auto:

a) Vereinbarung von Variablen:

   auto n = 123;

b) Rückgabetyp von Methoden:

    static auto test_09_helper_b() ...

c) Als Parameter.

==================================================

Modern C++:

Lambda, Gen. Funktionen:

Vieles wird auf Vorhandenes umgesetzt.

=========================================================

std::vector:           Daten: HEAP

std::initializer_list: Daten: STACK

Ersparnis: 50%

=========================================================

std::weak_ptr

Wozu ????????????????????????????

std::shared_ptr:  >>>>> Hmmm, dieser funktioniert nicht IMMER ????????

                 Der Speicher wird nicht in JEDEM Fall freigegeben // Puhhhhhh

a) Technik des Weak-Ptr

b) Was ist das Problem ??????????

Zyklen:
------

Haben wir die ??? Observer-Pattern:

a) Ein Observer kennt sein Subject.  // Shared_Ptr

b) Ein Subject kennt ein oder mehrere Observer  // Shared_Ptr

          Aber: IN dem Subject halten wir eine LISTE von Observern:  weak_ptr

          Notify >>= Empty.

Guidelines für Smart Pointer
----------------------------

A) nur Unique_Ptr:  Geht !!!

b) nur Shared_Ptr:  SW läuft prinzipiell, aber werden alle Objekte freigegeben: ????

c) Frage: 

   Hmm, will auf ein vorhandenes Objekt zugreifen:

   i) Kopie des Pointers in einer Shared_Ptr-Variablen:

               Diese Kopie stellt einen BESITZER dar // OWNER

            Neeee

            Visualisierung:   Prozessdaten visualiseren.

            Prozessdaten: Shared_Ptr

            Visualisierung: Will diese eine Shared_Ptr in die Hand nehmen 

            Neeeeeeeeeeeee:  Weak_ptr

            Weak_ptr  ==> lock ==> empty

============================================================

RAII

Konstruktor
Destruktor

Hüllenobjekt:

Resources:

Socket; Mutex; FILE; SqlConnection; GDI Handle

== open, lock, open
== close, unlock, close

std::mutex m;


lock
locks the mutex, blocks if the mutex is not available

unlock
unlocks the mutex

ACHTUNG: 

Prinzipiell richtig


while ....... 

m.lock();
// kritischer Anweisung  // break;  // throw 
m.unlock();

Idiom   // Clean Vorgehensweise:

a) std::mutex m;  // m wird quasi überhaupt nicht verwendet

b) Statt dessen: Eine Hülle:  std::lock_guard

c) Konsrtuktor // Destruktor


void safe_increment(int iterations)
{
    const std::lock_guard<std::mutex> lock(g_i_mutex);   // Hülle  // Wo ist lock // unlock
                                           // constructs a lock_guard, optionally locking the given mutex

    while (iterations-- > 0)
        g_i = g_i + 1;

    // g_i_mutex is automatically released when lock goes out of scope
    // destructs the lock_guard object, unlocks the underlying mutex
}
 
============================================================

std::string ==> Hält die Daten der Zeichenkette auf dem HEAP

Abhilfe:

std::string_view: Wo hält diese die Daten ??? Depends :)

Gegenfrage: Wo liegt "AAAAAAAAAAAAA" im Speicher ???

"AAAAAAAAAAAAA"

const char* cp = "AAAAAAAAAAAAA";

a) cp liegt am STACK.

b) globalen Datensegment // Code-Segment 

c) NICHT: HEAP


std::string_view sv { "asdasdasdadasd" };

std::string_view: Hülle:

a) Pointer der Anfangsadresse
b) Länge

Ein improved const char* Pointer:

============================================================

============================================================

C-Style Array:  FIXED-SIZE ARRAY

  int numbers [10];

Klasse std::array  FIXED-SIZE ARRAY

  std::array <int, 10> numbers;

Clean Code: Go for Klasse std::array.

a) STL Container

b) at-Methode // Range-Check

c) Length 

  printArray (int* ptr)  ===> printArray (numbers)

  printArray (int* ptr, int len)  ===> printArray (numbers, 10)

d) Kleines Problem: Template-Klasse:

    static void print(const std::array<int, 5>& array) {
        std::println("Length: {}", array.size());
    }

    Hmmm, das ist auf die Schnelle nicht lösbar.

e) Neuer Helfer:  std::span

std::span:

a) Anfangsadresse
b) Längenangabe (Elementen)

=======================================================

Noch ein Helfer:

std::variant

In einer std::variant Variablen können mehrere Werte unterschiedlichen
Typs abgelegt werden, zu einem Zeitpunkt nur EIN Wert.

Beispiel:

Excel  // Google Sheets: Cell

Zeichenkette
num. Wert
Datum 
Uhrzeit
Currency


Einen  Variant kann man "besuchen" ;)

=========================================

Neues if:

if zur Übersetzungszeit:

=========================================

Type-Rich Programming:  Clean

==> Repertoire

==> Man kann auch in C++ Eigenschaften von Typen abfragen.

C++ Reflection

==========================================
==========================================

Ja:     C++ ist (leider) eine wahnsinnig komplexe Sprache.

Templates // auto

Templates // auto als Parameter

Nein:   Vertraut.

Ist C++ eine Clean Programming Language.

Man kann in C++ clean programmieren.

Modern Aspekte => clean programmieren

==========================================
==========================================
