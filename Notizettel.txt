// =========================================================

Seminar "Clean Code"

Peter Loos

30+ Jahren

C/C++,  Java, C#,  Mobile Progr. (Java) // Android, JavaScript (Python)

   Rust

Guten Morgen

10.30 //  12.30 // ca. 15 Uhr  // 17 Uhr.

// =========================================================

2 Tools:

a) Unterlagen

Github

https://github.com/pelocpp

https://github.com/pelocpp/Seminar_Cpp_Clean_Code_November_2025

oder auch das Original:

https://github.com/pelocpp/cpp_clean_performant_secure


https://github.com/pelocpp/cpp_design_patterns



b) Visual Studio Community 2022

=======================================================

ToDo Liste:

Smart Pointer // std::shared_ptr // std::unique_ptr
       ==> std::weak_ptr
     
Besucher // Visitor

RAII

=======================================================

Clean Code C++

"Sauberer Code"

2 Flughöhen:

Von Oben:   Entwurf, Idiome, Design Pattern, 

Im Inneren: Elemente der Sprache, die Clean Code ermöglichen (Modern C++)

// Classic C++  // Modern C++ (C++ 11)


== Was sind meine Erwartungen

== Wo stehe ich in C++

== Was MUSS drin sein

== Ein Überblick tut es auch 

== Welche Sprachen spreche ich :)

// Misra, sauberer Code, 

// Kein Heap, Design Pattern, STL 

std::vector

STL:  Algorithmen   std::copy, std::transform, std::generate  // Lambda

=========================================================

Schnittstelle:

  Kontrakt, Vertrag

  Dieser ist an anderer Stelle zu implementieren.

Abstrakte Klasse:  Unvollständige Klasse

============================================================

Single Responsibility Prinzip (SRP)

Open-Closed Prinzip:

============================================================

== Habe Methoden / Klassen für einen bestimmten Anwendungsfall.

== Es kommen neue Anforderungen hinzu.


Wie löst man das ???

== Man versuche, vorhandene konkrete Realisierungen (methoden) durch eine Schnittstelle zu abstrahieren.

== Dadurch wird es "allgemeiner"

== Aufbauende Module können auf den Schnittstellen aufsetzen

== Es findet eine Entkopplung statt !!!
                  ===========

============================================================

Kann man "vordenken"  // Antizipatorischens Verhalten

Gratwanderung:   Könnte sich an dieser Stelle etwas ändern  

============================================================

Dependency Inversion Prinzip
----------------------------

„High-Level”-Module  ==> „Low-Level”-Module

Wenn Low-Level die Schnittstelle ändert: Problem ===> „High-Level”

==================================================

struct Point
{
   int m_x;
   int m_y;
}


FamilyTree ==> Relationships   // Enge Kopplung   ==>   Lose Kopplung

Besser:

FamilyTree ==> IRelationshipBrowser

Relationships  ==> IRelationshipBrowser

==================================================

Design Pattern:
---------------

Vorab:

== Text

== Bild

== Konzeptionelle Beispiel

== Real-World Beispiel

======================================================

Adapter
-------

Ermöglicht die Interaktion von Objekten mit inkompatiblen Schnittstellen.

== Ansprechen von inkompatiblen Methoden
== Benötige Zwischenschicht (KEINE Bibliothek): Hüllenobjekt (Wrapper)

   Ein Adapter ist ein Wrapper (Hüllenobjekt) um ein inkompatibles Objekt

Beispiel:

==: JSON
==> Daten:  XML
==> Daten:  JAML

Wiedervewenbare Lösung

==========================================

Strategy Pattern:
-----------------

== Ermöglicht den Austausch von Methoden

== Umbiegen von Aufrufen an bestimmte Realisierungen 

Beispiel:

UI Bibliothek:

== Kann zeichnen via GDI
== Kann zeichnen via Qt

a) draw (GDIContext) ........ Hmmm, diese Methode hängt von der Ausgabe DIREKT ab.

b) draw (Rectangle r)  .... Hmmm, wohin ???

   draw ==> Interface:

       interface IDraw:
          draw ();
         
        2 Mal realisieren:

        GDILibrary : public IDraw

        QtLibrary :  public IDraw

    Dies ist eine Umsetzung des Strategy - Pattern.

std::function:  

Ist ein Hüllenobjekt. Die Template Parameter beschreiben die SIGNATUR der gekapselten Methode.

Worum: Um quasi ALLES, was in C++ aufgerufen werden kann.

======================================================

Adapter
Strategy
Template Method

Template Method Pattern:   Einfach und Cool.


Beispiel:

Tetris 

Was haben alle 7 Figuren von Tetris während des Spielablaufs gemeinsam?

== Haben eine bestimmte Geometrie

== Sie bewegen sich auf eine bestimmte Weise identisch:

  -- nach links
  -- nach rechts
  -- nach unten
  -- drehen
  -- irgendwann ist die Bewegung zu Ende.

    Was ist das im Prinzip: Eine schablonenhafte Methode für ALLE Figuren.

    Template Method Pattern.

========================================================

Wann Adapter

Wann Strategy

Wann Template Method


Alle haben mit Methoden zu tun:

Adapter ===> Zielmethode ist DIREKT nicht aufrufbar

Template Methode ==> Kann einen allgemeinen Ablauf in EINER Methode vorgeben / festlegen.

Strategy ==> Austauschbarkeit von Funktionalität // Verhalten kann geändert werden.

// =========================================================

Allgemein:

a) Ein Pattern ist eine Hilfestellung.

b) Wie sehr muss ich mich an die Vorgaben halten???

c) Kollegen sollten das Pattern "wieder erkennen"

d) Abweichungen sind grundsätzlich möglich // man sollte sie begründen können.

  Am Ende: Es sollte die grundlegende Idee nicht geändert werden.

// =========================================================

Proxy:

Single Responsibility Idiom


Hülle: Ein Proxy kann als Hülle aufgefasst werden.

Diese kann zusätzliche Funktionalitäten erbringen,
die das Zielobjekt (SRP) unberührt lassen.

Lazy Loading
Eager Loading

Lazy: Faul // On Demand
Eager: Gierig

Smartphone // Embedded Device

Bilder Gallerie  // 10.000   // On Demand

== Durch wischen  // swipen   // Klein-Darstellung  // Thumb Nails // Ersatzdarstellung

Ein Bild: Benötigt viele Resources.

NICHT vorstellbar ist: Jedes Bild wird geladen.

==============================================================

Virtueller Konstruktor

// Prototype Pattern

Cooles Pattern

Erstelle eine Kopie eines Objekts durch einen Zeiger auf seinen Basistyp     Uhhhhhhhhhhh


a) Erstelle eine Kopie eines Objekts:    Kopier-Konstruktor

   Das ist nicht das Problem / die Frage ??????????

b) Beispiel / Motivation:

   Spieleprgrammierung.

   ChessFigure* board [8][8];

   Bauer:   Pawn
   Turm:    Rook
   König:   King
   Dame:    Queen
   Läufer:  Bishop

   class Pawn : public ChessFigure
   class Rook : public ChessFigure

   Nächste Schritt: Versuche // Zukunft :

       Kopie vom aktuellen Schachbrett: 


     ChessFigure*  copy[8][8] = board;   // 64 ChessFigure* Adressen / Pointer

     Will man hier Adressen kopieren ?????????????? Nein.

     Man will auch von den Figuren eine Kopie haben.  ====>  board[0][0]

     Ich will das Objekt, auf das der ZEIGER  board[0][0] zeigt, KOPIEREN.

     
     Das Kind ConcretePrototype leitet von Prototype ab.
     Deswegen geht das.

     ==============================================================

     Clean Code:

     Vererbung:   

     Wann setzt man Vererbung ein ???????????????????????

     Wenn man sich Methoden teilen möchten
     Wiederverwendung von Code
     Wenn es einen Hierarchie gibt ...

     Hilfestellung für diese Beobachtungen:
     -------------

     Klasse Rectangle
     Klasse ColoredRectangle

     Satz: Ein ColoredRectangle ist ein Rectangle

        Es gibt im Entwurf von SW Beziehungen // Relationsships:

        is-a Relationship // ist-ein Beziehung ===========>  Vererbung

    Klasse Point
    Klasse Line

    Satz: 

        Eine Linie hat viele Punkte

        Eine Linie ist ein Punkt : No
        Ein Punkt ist eine Linie:  No

        Eine Linie hat einen Anfangs- und Endepunkt.

        has-a Relationship // hat-ein Beziehung ===========>  Instanzvariablen

        Es sollte nur das eine Instanzvariable sein, was unbedingt benötigt wird.

        class Line
        {
             Point m_begin;
             Point m_end;
             int   i;           // NOOOOOOOOOOOOOOOO
             int   m_length;    // computed // computable property  // NOOOOOOOOOOOOOOOOO
                                // hmmmm, Berechnung dauert EXTREM lange ...
        }



  // class Line : public Point 
  // {
  // }

  Es gibt bei der is-a Beziehung SEHR SELTEN Abweichungen zum Entwurf.  // Barbara Liskov

  ======================================================================

  Frage:

  Methode ist in der Entwicklung ...

  Komplizierteres ... Hmm, das wird nichts .....

  ==> Neu schreiben // nochmals damit von vorne anfangen ...

  ==> kann man das eine oder anderen in ein Unterprogramm(-methode) auslagern
  
  ==> Bausteine ....

  ======================================================================

 Interfaces: >> Abstraktion

 YAGNI

 Zum Testen: 

 DRY:   ==> Haben wir das eine oder andere nicht in der STL ???

 Copy&Paste.

 ==> Abgabe // extr. Zeitdruck:

     Klasse 1 Fehler: Wurde nach 3 Tagen gefixed...

Usache: Ein Fehler wurde mit Copy & Paste wiederholt ...

POLS

===================================================================

const:

Wichtig oder nicht ??????????????????????????????????????

Auf eine Methode angewendet:

01: class Person
02: {
03: private:
04:     std::string   m_name;
05:     size_t        m_age;
06: 
07: public:
08:     Person() = default;
09:     Person(const std::string& name, size_t age)
10:         : m_name{ name }, m_age{ age }
11:     {}
12: 
13:     std::string getName() const { return m_name; }  // hier const auf die Methode angewendet ..
14:     size_t getAge() const { return m_age; }
15: };


const bedeutet hier (Lesbarkeit): Das Person-Objekt bleibt unverändert !

Noch was anderes ???

ii) Wenn ich aus Versehen ändern sollte, dann warnt mich der Compiler !!! Error.

iii) OO Programmierung

     Funktionale Programmierung  ==> Werbung: Performanz.

     CPU:  Reordering der CPU Befehle // CPU Pipelining // Performanz  // Parallelisierung ganz tief unten.

     Warum geht das: Kein STATE

     C++: Hmm, Problem der Instanzvariablen.

     Code-Generator // -Optimizer: Welche Methoden kann ein Optimizer am besten optimieren: 
     Solche, die den State nicht verändern: 'const'

     Fazit:  'const' ==> Optimizer  // Yes  // Hint

==============================================================

01: class Person
02: {
03: private:
04:     std::string   m_name;
05:     size_t        m_age;
06: 
07: public:
08:     Person() = default;
09:     Person(const std::string& name, size_t age)
10:         : m_name{ name }, m_age{ age }
11:     {}
12: 
13:     std::string getName() const { return m_name; }
14:     size_t getAge() const { return m_age; }
15: };

Gute Klasse / schlechte Klasse ???

Zeile 13: Hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm

const std::string& getName() const { return m_name; }

Eine kleine Frage verbunden: Wie lange ist diese Referenz gültig ???

So lange das Objekt Person lebt.

==========================================================================

STL

Why:  Better // Clean Clode relies upon STL

Robustheit

Walk-Through ...


STL:

== Container
== Iteratoren
== Algorithmen
== Aufrufbare Objekte (Funktor)

=> Transparenz

==========================

Jeder STL Container verwaltet seine Daten nach bestimmten Regeln.

NICHT alle Regeln sind publiziert // beschrieben.

std::vector:  Die Daten liegen DICHT aneinander. // ALLE 

std::list:    Hier liegen die Daten im Stile einer Linked List im Speicher.

Hash-Tabelle:  Python: Dictionary

               std::unordered_map

std::map:      Balancierter Baum  // Red-Black Tree


std::vector

6, 9, 13, 19, 28, 42, 63

neuer Wert = alter Wert * 1.5;

===================================================

STL Container

Operator[]:  Dieser geht nur bei "sequentiellen" Container:

   Daten liegen DICHT im Speicher.

==> Go for "Iteratoren"

Was ist ein STL Iterator ???

Man kann auch "Position" sagen.

Ein Iterator beschreibt eine Position in einem Container.

Vorsicht: Eine Position ist NICHT gleich dem WERT an dieser Position.

Offensichtlich hat jeder STL Container einen eigenen Typ für derartige Positionen.


Welches kOnzept haben Iteratoren:

3 Methoden:

Next
ValueOf
Equals

C++:  Konzept des Überladens von Operatoren:

operator ++
operator *
operator ==



